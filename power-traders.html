<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Power Traders - Chillz</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0f; color: #e0e0e0; font-family: 'SF Mono', 'Fira Code', monospace; font-size: 13px; }
.header { background: #12121a; border-bottom: 1px solid #1e1e2e; padding: 16px 24px; display: flex; justify-content: space-between; align-items: center; }
.header h1 { font-size: 18px; color: #7dd3fc; }

.control-section { background: #12121a; border-bottom: 1px solid #1e1e2e; padding: 16px 24px; }
.control-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.control-desc { color: #666; font-size: 12px; margin-bottom: 12px; }
.btn { padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 13px; font-family: inherit; border: 1px solid; transition: all 0.15s; }
.btn-primary { background: #7dd3fc22; border-color: #7dd3fc44; color: #7dd3fc; }
.btn-primary:hover { background: #7dd3fc33; }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-green { background: #22c55e22; border-color: #22c55e44; color: #22c55e; }
.btn-green:hover { background: #22c55e33; }
.btn-red { background: #ef444422; border-color: #ef444444; color: #ef4444; }
.btn-red:hover { background: #ef444433; }
.btn-export { background: #3b82f622; border-color: #3b82f644; color: #3b82f6; }
.btn-export:hover { background: #3b82f633; }

.options { display: flex; gap: 16px; margin-top: 10px; align-items: center; flex-wrap: wrap; }
.options label { color: #666; font-size: 12px; display: flex; align-items: center; gap: 4px; }
.options input[type=range] { width: 80px; accent-color: #7dd3fc; }
.options .range-val { color: #7dd3fc; font-weight: 600; min-width: 24px; text-align: center; }

.token-panel { background: #0d0d14; border-bottom: 1px solid #1e1e2e; padding: 12px 24px; display: none; }
.token-panel-title { color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
.token-chips { display: flex; gap: 6px; flex-wrap: wrap; }
.token-chip { background: #1a1a2e; border: 1px solid #2a2a3e; padding: 4px 10px; border-radius: 6px; font-size: 11px; display: inline-flex; align-items: center; gap: 6px; }
.token-chip .sym { color: #7dd3fc; font-weight: 600; }
.token-chip .vol { color: #666; }
.token-chip.scanning { border-color: #f59e0b44; }
.token-chip.done { border-color: #22c55e44; }

.progress-section { padding: 16px 24px; display: none; }
.progress-bar { background: #1a1a2e; border-radius: 6px; height: 8px; overflow: hidden; margin-bottom: 8px; }
.progress-fill { background: #7dd3fc; height: 100%; width: 0%; transition: width 0.3s; }
.progress-text { color: #666; font-size: 12px; }
.progress-log { max-height: 120px; overflow-y: auto; margin-top: 8px; font-size: 11px; color: #555; }
.progress-log div { padding: 1px 0; }
.progress-log .ok { color: #22c55e; }
.progress-log .warn { color: #f59e0b; }
.progress-log .skip { color: #666; }
.progress-log .err { color: #ef4444; }
.progress-log .info { color: #7dd3fc; }

.summary-bar { display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; padding: 16px 24px; display: none; }
.summary-stat { background: #1a1a2e; border: 1px solid #2a2a3e; padding: 8px 16px; border-radius: 8px; text-align: center; }
.summary-stat .num { font-size: 20px; font-weight: 700; color: #7dd3fc; }
.summary-stat .num.green { color: #22c55e; }
.summary-stat .num.yellow { color: #f59e0b; }
.summary-stat .num.red { color: #ef4444; }
.summary-stat .label { font-size: 11px; color: #666; margin-top: 2px; }

.filters-bar { background: #12121a; border-bottom: 1px solid #1e1e2e; padding: 8px 24px; display: none; gap: 8px; flex-wrap: wrap; align-items: center; }
.filter-btn { background: #1a1a2e; border: 1px solid #2a2a3e; color: #999; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; font-family: inherit; transition: all 0.15s; }
.filter-btn:hover { border-color: #444; color: #ccc; }
.filter-btn.active { border-color: #7dd3fc; color: #7dd3fc; background: #7dd3fc11; }
.filter-sep { color: #333; margin: 0 4px; }
.min-tokens-filter { display: flex; align-items: center; gap: 4px; }
.min-tokens-filter label { color: #666; font-size: 11px; }
.min-tokens-filter input { width: 50px; background: #1a1a2e; border: 1px solid #2a2a3e; color: #e0e0e0; padding: 4px 6px; border-radius: 4px; font-family: inherit; font-size: 11px; text-align: center; }

.actions-bar { background: #12121a; border-bottom: 1px solid #1e1e2e; padding: 8px 24px; display: none; gap: 8px; align-items: center; }
.selected-count { color: #666; font-size: 11px; margin-left: 8px; }

.table-wrap { padding: 0 24px 24px; }
table { width: 100%; border-collapse: collapse; }
th { background: #12121a; position: sticky; top: 0; z-index: 10; text-align: left; padding: 10px 8px; color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #1e1e2e; cursor: pointer; user-select: none; }
th:hover { color: #999; }
th.sorted { color: #7dd3fc; }
td { padding: 8px; border-bottom: 1px solid #1a1a2e; vertical-align: middle; }
tr:hover { background: #ffffff05; }

.addr { font-size: 12px; display: flex; align-items: center; gap: 6px; }
.addr a { color: #7dd3fc; text-decoration: none; }
.addr a:hover { text-decoration: underline; }
.copy-btn { cursor: pointer; opacity: 0.3; font-size: 10px; }
.copy-btn:hover { opacity: 1; }

.badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; }
.badge.human { background: #22c55e22; color: #22c55e; border: 1px solid #22c55e33; }
.badge.platform { background: #3b82f622; color: #3b82f6; border: 1px solid #3b82f633; }
.badge.cex { background: #6b728022; color: #6b7280; border: 1px solid #6b728033; }
.badge.bot { background: #f59e0b22; color: #f59e0b; border: 1px solid #f59e0b33; }

.tag { display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 10px; font-weight: 600; margin-right: 3px; }
.tag.power { background: #f59e0b22; color: #f59e0b; }
.tag.whale { background: #7dd3fc22; color: #7dd3fc; }
.tag.tracked { background: #22c55e22; color: #22c55e; }
.tag.trader { background: #8b5cf622; color: #8b5cf6; }

.sol-bal { color: #f59e0b; font-weight: 600; }
.sol-bal.zero { color: #444; font-weight: normal; }
.swap-count { color: #22c55e; font-weight: 600; }
.swap-count.zero { color: #444; font-weight: normal; }
.token-count { color: #7dd3fc; font-weight: 700; }

.token-list { font-size: 10px; color: #888; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

.links { display: flex; gap: 4px; }
.links a { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 10px; text-decoration: none; }
.links .profile { background: #f59e0b22; color: #f59e0b; }
.links .profile:hover { background: #f59e0b44; }
.links .solscan { background: #3b82f622; color: #3b82f6; }
.links .solscan:hover { background: #3b82f644; }
.links .birdeye { background: #22c55e22; color: #22c55e; }
.links .birdeye:hover { background: #22c55e44; }
.links .gmgn { background: #8b5cf622; color: #8b5cf6; }
.links .gmgn:hover { background: #8b5cf644; }

.checkbox { width: 16px; height: 16px; cursor: pointer; accent-color: #22c55e; }
.toast { position: fixed; bottom: 20px; right: 20px; background: #22c55e; color: #000; padding: 8px 16px; border-radius: 6px; font-size: 12px; display: none; z-index: 1000; }
.empty-state { text-align: center; padding: 80px 24px; color: #444; }
.empty-state h2 { font-size: 16px; margin-bottom: 8px; color: #555; }
</style>
<link rel="stylesheet" href="shared.css"></head>
<body>

<div class="header">
    <h1>Power Traders Discovery</h1>
</div>

<div class="control-section">
    <div class="control-desc">Scans trending tokens on DexScreener, finds wallets trading across multiple tokens, and surfaces the most active power traders. No address needed — just click Discover.</div>
    <div class="control-row">
        <button class="btn btn-primary" id="discoverBtn" onclick="startDiscovery()">Discover Power Traders</button>
        <button class="btn btn-red" id="stopBtn" onclick="stopScan()" style="display:none">Stop</button>
    </div>
    <div class="options">
        <label>Tokens: <input type="range" id="tokenCount" min="5" max="30" value="15" oninput="this.nextElementSibling.textContent=this.value"><span class="range-val">15</span></label>
        <label>Min overlap: <input type="range" id="minOverlap" min="2" max="5" value="3" oninput="this.nextElementSibling.textContent=this.value"><span class="range-val">3</span></label>
        <label>Pages/token: <input type="range" id="pagesPerToken" min="1" max="5" value="2" oninput="this.nextElementSibling.textContent=this.value"><span class="range-val">2</span></label>
        <label>Delay (ms): <input type="range" id="delayMs" min="50" max="500" value="100" step="50" oninput="this.nextElementSibling.textContent=this.value"><span class="range-val">100</span></label>
    </div>
</div>

<div class="token-panel" id="tokenPanel">
    <div class="token-panel-title">Trending Tokens</div>
    <div class="token-chips" id="tokenChips"></div>
</div>

<div class="progress-section" id="progressSection">
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <div class="progress-text" id="progressText">Starting...</div>
    <div class="progress-log" id="progressLog"></div>
</div>

<div class="summary-bar" id="summaryBar"></div>

<div class="filters-bar" id="filtersBar">
    <button class="filter-btn active" data-filter="all" onclick="setFilter('all', this)">All</button>
    <button class="filter-btn" data-filter="HUMAN_TRADER" onclick="setFilter('HUMAN_TRADER', this)">Human Only</button>
    <button class="filter-btn" data-filter="whale" onclick="setFilter('whale', this)">Whale</button>
    <button class="filter-btn" data-filter="tracked" onclick="setFilter('tracked', this)">Tracked</button>
    <span class="filter-sep">|</span>
    <div class="min-tokens-filter">
        <label>Min tokens:</label>
        <input type="number" id="filterMinTokens" value="3" min="2" max="20" onchange="renderTable()">
    </div>
</div>

<div class="actions-bar" id="actionsBar">
    <button class="btn btn-green" onclick="copySelected()">Copy selected</button>
    <button class="btn btn-green" onclick="copyAll()">Copy all filtered</button>
    <button class="btn btn-export" onclick="exportJSON()">Export JSON</button>
    <span class="selected-count" id="selectedCount">0 selected</span>
</div>

<div class="table-wrap">
    <table id="resultsTable" style="display:none">
        <thead>
        <tr>
            <th style="width:30px"><input type="checkbox" class="checkbox" onclick="toggleAll(this)"></th>
            <th data-sort="tokenCount" style="width:60px">Tokens</th>
            <th data-sort="address">Wallet</th>
            <th data-sort="solBalance" style="width:80px">SOL Bal</th>
            <th data-sort="swapCount" style="width:70px">Swaps</th>
            <th data-sort="totalSigs" style="width:70px">Total Txs</th>
            <th data-sort="classification" style="width:90px">Type</th>
            <th>Tags</th>
            <th>Tokens Traded</th>
            <th style="width:160px">Links</th>
        </tr>
        </thead>
        <tbody id="tbody"></tbody>
    </table>
    <div class="empty-state" id="emptyState">
        <h2>Discover Power Traders</h2>
        <p>Auto-scans trending tokens and finds wallets trading across multiple tokens — no address needed.</p>
    </div>
</div>

<div class="toast" id="toast"></div>

<script>
function getApiKey() {
    let key = localStorage.getItem('helius_api_key');
    if (!key) {
        key = prompt('Enter your Helius API key:');
        if (key) localStorage.setItem('helius_api_key', key);
    }
    return key;
}
let API_KEY = getApiKey();
const RPC_BASE = 'https://mainnet.helius-rpc.com/?api-key=';
const ENHANCED = 'https://api-mainnet.helius-rpc.com/v0/addresses';

// Known programs/addresses to skip when extracting wallets
const KNOWN_SKIP = new Set([
    '11111111111111111111111111111111',
    'ComputeBudget111111111111111111111111111111',
    'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
    'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
    'JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4',   // Jupiter v6
    'JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB',   // Jupiter v4
    'whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc',   // Orca Whirlpool
    '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8', // Raydium AMM
    'CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK', // Raydium CLMM
    'AVUCZyuT35YSuj4RH7fwiyPu82Djn2Hfg7y2ND2XcnZH', // Photon fees
    '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P',  // Pump.fun program
    'TSWAPaqyCSx2KABk68Shruf4rp7CZNYoAt5gkdxoP2b',  // Tensor swap
    'M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K',  // Magic Eden v2
]);

// Load tracked wallets
let trackedAddrs = new Set();
try {
    const saved = localStorage.getItem('tracked_wallets');
    if (saved) trackedAddrs = new Set(JSON.parse(saved));
} catch(e) {}

let results = [];
let currentFilter = 'all';
let currentSort = { key: 'tokenCount', dir: -1 };
let isRunning = false;
let abortRequested = false;

async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function rpcCall(method, params) {
    const resp = await fetch(RPC_BASE + API_KEY, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
    });
    return resp.json();
}

function setProgress(pct, text) {
    document.getElementById('progressFill').style.width = pct + '%';
    document.getElementById('progressText').textContent = text;
}

function log(text, cls) {
    const el = document.getElementById('progressLog');
    const div = document.createElement('div');
    if (cls) div.className = cls;
    div.textContent = text;
    el.appendChild(div);
    el.scrollTop = el.scrollHeight;
}

function shortAddr(a) { return a.slice(0, 6) + '...' + a.slice(-4); }

function stopScan() {
    abortRequested = true;
    document.getElementById('stopBtn').disabled = true;
    document.getElementById('stopBtn').textContent = 'Stopping...';
    log('Stop requested, finishing current batch...', 'warn');
}

// --- Session Cache ---
const CACHE_KEY = 'powertraders_cache';
const CACHE_TTL = 60 * 60 * 1000; // 1 hour

function loadCache() {
    try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return null;
        const cached = JSON.parse(raw);
        if (Date.now() - cached.time > CACHE_TTL) { localStorage.removeItem(CACHE_KEY); return null; }
        return cached;
    } catch(e) { return null; }
}

function saveCache(data) {
    try {
        localStorage.setItem(CACHE_KEY, JSON.stringify({ ...data, time: Date.now() }));
    } catch(e) {}
}

// --- Load cached results on page load ---
try {
    const cached = loadCache();
    if (cached && cached.results && cached.results.length) {
        results = cached.results;
        document.getElementById('emptyState').style.display = 'none';
        document.getElementById('resultsTable').style.display = 'table';
        document.getElementById('filtersBar').style.display = 'flex';
        document.getElementById('actionsBar').style.display = 'flex';
        if (cached.tokens) {
            document.getElementById('tokenPanel').style.display = 'block';
            document.getElementById('tokenChips').innerHTML = cached.tokens.map(t =>
                '<div class="token-chip done"><span class="sym">' + (t.symbol || '?') + '</span><span class="vol">$' + formatVol(t.volume) + '</span></div>'
            ).join('');
        }
        showSummary();
        renderTable();
    }
} catch(e) {}

function formatVol(v) {
    if (!v) return '0';
    if (v >= 1e6) return (v / 1e6).toFixed(1) + 'M';
    if (v >= 1e3) return (v / 1e3).toFixed(1) + 'K';
    return Math.round(v).toString();
}

// ========== MAIN DISCOVERY FLOW ==========

async function startDiscovery() {
    if (isRunning) return;
    API_KEY = getApiKey();
    if (!API_KEY) return;

    isRunning = true;
    abortRequested = false;
    results = [];

    document.getElementById('discoverBtn').disabled = true;
    document.getElementById('stopBtn').style.display = '';
    document.getElementById('stopBtn').disabled = false;
    document.getElementById('stopBtn').textContent = 'Stop';
    document.getElementById('progressSection').style.display = 'block';
    document.getElementById('progressLog').innerHTML = '';
    document.getElementById('emptyState').style.display = 'none';
    document.getElementById('resultsTable').style.display = 'none';
    document.getElementById('summaryBar').style.display = 'none';
    document.getElementById('filtersBar').style.display = 'none';
    document.getElementById('actionsBar').style.display = 'none';

    const tokenCount = parseInt(document.getElementById('tokenCount').value) || 15;
    const minOverlap = parseInt(document.getElementById('minOverlap').value) || 3;
    const pagesPerToken = parseInt(document.getElementById('pagesPerToken').value) || 2;
    const delayMs = parseInt(document.getElementById('delayMs').value) || 100;

    let scannedTokens = [];

    try {
        // ===== PHASE 1: Fetch Trending Tokens from DexScreener =====
        setProgress(2, 'Phase 1: Fetching trending tokens from DexScreener...');
        log('Fetching boosted tokens from DexScreener...', 'info');

        let solanaTokens = [];
        try {
            const boostResp = await fetch('https://api.dexscreener.com/token-boosts/top/v1');
            if (!boostResp.ok) throw new Error('DexScreener boost API returned ' + boostResp.status);
            const boostData = await boostResp.json();

            // Filter to Solana only, deduplicate by tokenAddress
            const seen = new Set();
            const solanaMints = [];
            for (const item of boostData) {
                if (item.chainId === 'solana' && item.tokenAddress && !seen.has(item.tokenAddress)) {
                    seen.add(item.tokenAddress);
                    solanaMints.push(item.tokenAddress);
                }
            }

            log('Found ' + solanaMints.length + ' unique Solana boosted tokens', 'ok');

            // Enrich with token details (DexScreener supports comma-separated, max ~30)
            if (solanaMints.length > 0) {
                const batchSize = 30;
                for (let i = 0; i < solanaMints.length; i += batchSize) {
                    const batch = solanaMints.slice(i, i + batchSize);
                    try {
                        const detailResp = await fetch('https://api.dexscreener.com/tokens/v1/solana/' + batch.join(','));
                        if (detailResp.ok) {
                            const pairs = await detailResp.json();
                            // Group by baseToken address, take highest volume pair per token
                            const byToken = {};
                            for (const p of pairs) {
                                const addr = p.baseToken?.address;
                                if (!addr) continue;
                                const vol = p.volume?.h24 || 0;
                                if (!byToken[addr] || vol > byToken[addr].volume) {
                                    byToken[addr] = {
                                        address: addr,
                                        symbol: p.baseToken?.symbol || '???',
                                        name: p.baseToken?.name || '',
                                        volume: vol,
                                        priceUsd: p.priceUsd || '0',
                                        pairAddress: p.pairAddress || ''
                                    };
                                }
                            }
                            for (const t of Object.values(byToken)) {
                                if (!solanaTokens.find(x => x.address === t.address)) {
                                    solanaTokens.push(t);
                                }
                            }
                        }
                    } catch(e) {
                        log('DexScreener detail fetch error: ' + e.message, 'err');
                    }
                }
            }
        } catch(e) {
            log('DexScreener error: ' + e.message + ' — falling back to empty list', 'err');
        }

        // Sort by volume, take top N
        solanaTokens.sort((a, b) => (b.volume || 0) - (a.volume || 0));
        solanaTokens = solanaTokens.slice(0, tokenCount);
        scannedTokens = solanaTokens;

        if (solanaTokens.length === 0) {
            log('No trending tokens found. Try again later.', 'err');
            setProgress(0, 'No tokens found');
            isRunning = false;
            document.getElementById('discoverBtn').disabled = false;
            document.getElementById('stopBtn').style.display = 'none';
            return;
        }

        log('Selected top ' + solanaTokens.length + ' tokens by 24h volume', 'ok');

        // Show token chips
        document.getElementById('tokenPanel').style.display = 'block';
        document.getElementById('tokenChips').innerHTML = solanaTokens.map((t, i) =>
            '<div class="token-chip" id="chip' + i + '"><span class="sym">' + t.symbol + '</span><span class="vol">$' + formatVol(t.volume) + '</span></div>'
        ).join('');

        setProgress(10, 'Phase 1 complete: ' + solanaTokens.length + ' tokens selected');

        if (abortRequested) throw new Error('Aborted');

        // ===== PHASE 2: Scan Token Transactions =====
        log('--- Phase 2: Scanning token transactions via Helius ---', 'info');

        const walletMap = {}; // address -> { tokens: Set<symbol>, swapCount: number }

        for (let ti = 0; ti < solanaTokens.length; ti++) {
            if (abortRequested) throw new Error('Aborted');

            const token = solanaTokens[ti];
            const chipEl = document.getElementById('chip' + ti);
            if (chipEl) chipEl.classList.add('scanning');

            const pctBase = 10 + Math.floor((ti / solanaTokens.length) * 40);
            setProgress(pctBase, 'Phase 2: Scanning ' + token.symbol + ' (' + (ti + 1) + '/' + solanaTokens.length + ')');
            log('Scanning ' + token.symbol + ' (' + token.address.slice(0, 8) + '...)');

            let allTxs = [];
            let beforeSig = null;
            for (let page = 0; page < pagesPerToken; page++) {
                if (abortRequested) break;
                let url = ENHANCED + '/' + token.address + '/transactions?api-key=' + API_KEY + '&limit=100';
                if (beforeSig) url += '&before=' + beforeSig;
                try {
                    const resp = await fetch(url);
                    if (!resp.ok) {
                        if (resp.status === 429) { await sleep(2000); page--; continue; }
                        log('  HTTP ' + resp.status + ' for ' + token.symbol, 'err');
                        break;
                    }
                    const data = await resp.json();
                    if (!data || !data.length) break;
                    allTxs = allTxs.concat(data);
                    beforeSig = data[data.length - 1].signature;
                    if (data.length < 100) break;
                } catch(e) {
                    log('  Fetch error: ' + e.message, 'err');
                    break;
                }
                await sleep(delayMs);
            }

            // Extract fee payers from SWAP transactions
            let tokenWallets = 0;
            for (const tx of allTxs) {
                if (tx.transactionError) continue;
                const txType = tx.type || '';
                if (!/SWAP/.test(txType)) continue;
                const fp = tx.feePayer;
                if (!fp || KNOWN_SKIP.has(fp)) continue;
                if (!walletMap[fp]) walletMap[fp] = { tokens: new Set(), swapCount: 0 };
                walletMap[fp].tokens.add(token.symbol);
                walletMap[fp].swapCount++;
                tokenWallets++;
            }

            log('  ' + token.symbol + ': ' + allTxs.length + ' txs, ' + tokenWallets + ' swap fee-payers extracted', 'ok');
            if (chipEl) { chipEl.classList.remove('scanning'); chipEl.classList.add('done'); }
        }

        const totalWallets = Object.keys(walletMap).length;
        log('Phase 2 complete: ' + totalWallets + ' unique wallets across all tokens', 'info');

        if (abortRequested) throw new Error('Aborted');

        // ===== PHASE 3: Classify Power Traders =====
        log('--- Phase 3: Classifying power traders (min ' + minOverlap + ' tokens) ---', 'info');

        // Filter to wallets in minOverlap+ tokens
        const powerWallets = [];
        for (const [addr, data] of Object.entries(walletMap)) {
            if (data.tokens.size >= minOverlap) {
                powerWallets.push({
                    address: addr,
                    tokenCount: data.tokens.size,
                    swapCount: data.swapCount,
                    tokenSymbols: Array.from(data.tokens)
                });
            }
        }
        powerWallets.sort((a, b) => b.tokenCount - a.tokenCount);

        log(powerWallets.length + ' wallets found in ' + minOverlap + '+ tokens', powerWallets.length > 0 ? 'ok' : 'warn');
        setProgress(55, 'Phase 3: Classifying ' + powerWallets.length + ' power traders...');

        if (powerWallets.length === 0) {
            setProgress(100, 'Done — no power traders found. Try lowering min overlap or increasing tokens.');
            log('No wallets traded across ' + minOverlap + '+ tokens. Try different settings.', 'warn');
            isRunning = false;
            document.getElementById('discoverBtn').disabled = false;
            document.getElementById('stopBtn').style.display = 'none';
            return;
        }

        // Batch getMultipleAccounts for SOL balances
        const BATCH_ACCT = 100;
        const balanceMap = {};
        for (let i = 0; i < powerWallets.length; i += BATCH_ACCT) {
            if (abortRequested) throw new Error('Aborted');
            const batch = powerWallets.slice(i, i + BATCH_ACCT).map(w => w.address);
            try {
                const resp = await rpcCall('getMultipleAccounts', [batch, { encoding: 'jsonParsed' }]);
                if (resp.result && resp.result.value) {
                    resp.result.value.forEach((acct, idx) => {
                        const addr = batch[idx];
                        if (!acct) { balanceMap[addr] = { sol: 0, exec: false, isToken: false }; return; }
                        balanceMap[addr] = {
                            sol: (acct.lamports || 0) / 1e9,
                            exec: !!acct.executable,
                            isToken: acct.data && acct.data.program === 'spl-token'
                        };
                    });
                }
            } catch(e) {
                log('Balance batch error: ' + e.message, 'err');
            }
            await sleep(delayMs);
        }

        // Pre-filter programs and token accounts
        const filteredWallets = powerWallets.filter(w => {
            const info = balanceMap[w.address];
            if (!info) return true;
            if (info.exec) { log(shortAddr(w.address) + ' -> program (skip)', 'skip'); return false; }
            if (info.isToken) { log(shortAddr(w.address) + ' -> token account (skip)', 'skip'); return false; }
            return true;
        });

        log(filteredWallets.length + ' wallets after pre-filter (removed programs/token accounts)', 'ok');

        // Parallel classification (8 at a time)
        const PARALLEL = 8;

        async function classifyOne(wallet) {
            const short = shortAddr(wallet.address);
            const info = balanceMap[wallet.address] || { sol: 0 };
            try {
                const [txPage, sigResp] = await Promise.all([
                    fetch(ENHANCED + '/' + wallet.address + '/transactions?api-key=' + API_KEY + '&limit=100').then(r => r.ok ? r.json() : []).catch(() => []),
                    rpcCall('getSignaturesForAddress', [wallet.address, { limit: 1000 }]).catch(() => ({ result: [] }))
                ]);

                const totalSigs = sigResp.result ? sigResp.result.length : 0;

                let swapCount = 0, feePayer = 0;
                const interactors = {};
                for (const tx of txPage) {
                    if (/SWAP/.test(tx.type || '')) swapCount++;
                    if (tx.feePayer === wallet.address) feePayer++;
                    if (tx.feePayer && tx.feePayer !== wallet.address) interactors[tx.feePayer] = true;
                }
                const uniqueCount = Object.keys(interactors).length;

                // Classification
                let classification = 'UNKNOWN';
                if (uniqueCount > 15 && feePayer === 0) {
                    classification = 'CEX_OR_PROTOCOL';
                } else if (totalSigs >= 1000 && feePayer === 0) {
                    classification = 'CEX_OR_PROTOCOL';
                } else if (info.sol > 5000 && totalSigs >= 500) {
                    classification = 'CEX_OR_PROTOCOL';
                } else if (swapCount > 0 && feePayer > 0) {
                    classification = 'HUMAN_TRADER';
                } else if (swapCount > 0 && feePayer === 0) {
                    if (uniqueCount > 10) classification = 'CEX_OR_PROTOCOL';
                    else classification = 'HUMAN_VIA_PLATFORM';
                } else {
                    classification = 'UNKNOWN';
                }

                // Tags
                const tags = [];
                if (wallet.tokenCount >= 5) tags.push('POWER');
                if (info.sol > 500) tags.push('WHALE');
                if (trackedAddrs.has(wallet.address)) tags.push('TRACKED');
                if (swapCount > 0 && feePayer > 0) tags.push('TRADER');

                const cls = classification === 'HUMAN_TRADER' ? 'ok' : classification === 'HUMAN_VIA_PLATFORM' ? 'info' : 'skip';
                log(short + ' -> ' + classification + ' | ' + wallet.tokenCount + ' tokens, ' + swapCount + ' swaps, ' + info.sol.toFixed(1) + ' SOL' + (tags.length ? ' [' + tags.join(',') + ']' : ''), cls);

                return {
                    address: wallet.address,
                    tokenCount: wallet.tokenCount,
                    tokenSymbols: wallet.tokenSymbols,
                    solBalance: Math.round(info.sol * 100) / 100,
                    swapCount: swapCount,
                    totalSigs: totalSigs,
                    classification: classification,
                    tags: tags,
                    isTracked: trackedAddrs.has(wallet.address)
                };
            } catch(e) {
                log(short + ' -> error: ' + e.message, 'err');
                return {
                    address: wallet.address,
                    tokenCount: wallet.tokenCount,
                    tokenSymbols: wallet.tokenSymbols,
                    solBalance: (info.sol || 0),
                    swapCount: wallet.swapCount,
                    totalSigs: 0,
                    classification: 'ERROR',
                    tags: [],
                    isTracked: false
                };
            }
        }

        for (let i = 0; i < filteredWallets.length; i += PARALLEL) {
            if (abortRequested) throw new Error('Aborted');
            const batch = filteredWallets.slice(i, i + PARALLEL);
            const pct = 55 + Math.floor((i / filteredWallets.length) * 40);
            setProgress(pct, 'Phase 3: Classifying ' + Math.min(i + PARALLEL, filteredWallets.length) + '/' + filteredWallets.length + ' (8x parallel)');
            const batchResults = await Promise.all(batch.map(w => classifyOne(w)));
            for (const r of batchResults) {
                if (r) results.push(r);
            }
            await sleep(delayMs);
        }

        // Sort by token count descending
        results.sort((a, b) => b.tokenCount - a.tokenCount);

        setProgress(100, 'Done! Found ' + results.length + ' power traders across ' + solanaTokens.length + ' tokens');
        log('Discovery complete: ' + results.length + ' power traders found!', 'ok');

        // Save to cache
        saveCache({ results, tokens: scannedTokens.map(t => ({ symbol: t.symbol, volume: t.volume })) });

        // Show results
        document.getElementById('resultsTable').style.display = 'table';
        document.getElementById('filtersBar').style.display = 'flex';
        document.getElementById('actionsBar').style.display = 'flex';
        showSummary();
        renderTable();

    } catch(e) {
        if (e.message === 'Aborted') {
            log('Scan aborted by user.', 'warn');
            setProgress(0, 'Scan aborted');
            if (results.length > 0) {
                saveCache({ results, tokens: scannedTokens.map(t => ({ symbol: t.symbol, volume: t.volume })) });
                document.getElementById('resultsTable').style.display = 'table';
                document.getElementById('filtersBar').style.display = 'flex';
                document.getElementById('actionsBar').style.display = 'flex';
                showSummary();
                renderTable();
            }
        } else {
            log('Fatal error: ' + e.message, 'err');
            setProgress(0, 'Error: ' + e.message);
        }
    }

    isRunning = false;
    document.getElementById('discoverBtn').disabled = false;
    document.getElementById('stopBtn').style.display = 'none';
}

// ========== DISPLAY ==========

function showSummary() {
    const humanCount = results.filter(r => r.classification === 'HUMAN_TRADER').length;
    const whaleCount = results.filter(r => r.tags.includes('WHALE')).length;
    const trackedCount = results.filter(r => r.isTracked).length;
    const powerCount = results.filter(r => r.tags.includes('POWER')).length;
    document.getElementById('summaryBar').style.display = 'flex';
    document.getElementById('summaryBar').innerHTML =
        '<div class="summary-stat"><div class="num">' + results.length + '</div><div class="label">Total wallets</div></div>' +
        '<div class="summary-stat"><div class="num green">' + humanCount + '</div><div class="label">Human traders</div></div>' +
        '<div class="summary-stat"><div class="num yellow">' + powerCount + '</div><div class="label">Power (5+ tokens)</div></div>' +
        '<div class="summary-stat"><div class="num">' + whaleCount + '</div><div class="label">Whales (500+ SOL)</div></div>' +
        '<div class="summary-stat"><div class="num green">' + trackedCount + '</div><div class="label">Already tracked</div></div>';
}

function getBadgeClass(c) {
    if (c === 'HUMAN_TRADER') return 'human';
    if (c === 'HUMAN_VIA_PLATFORM') return 'platform';
    if (c === 'CEX_OR_PROTOCOL') return 'cex';
    return 'bot';
}

function getBadgeLabel(c) {
    const labels = { 'HUMAN_TRADER': 'Human', 'HUMAN_VIA_PLATFORM': 'Platform', 'CEX_OR_PROTOCOL': 'CEX', 'UNKNOWN': '???', 'ERROR': 'Error' };
    return labels[c] || c;
}

function getFilteredResults() {
    const minTokens = parseInt(document.getElementById('filterMinTokens').value) || 2;
    let filtered = results.filter(r => r.tokenCount >= minTokens);
    if (currentFilter === 'HUMAN_TRADER') filtered = filtered.filter(r => r.classification === 'HUMAN_TRADER');
    else if (currentFilter === 'whale') filtered = filtered.filter(r => r.tags.includes('WHALE'));
    else if (currentFilter === 'tracked') filtered = filtered.filter(r => r.isTracked);
    return filtered;
}

function renderTable() {
    let filtered = getFilteredResults();

    filtered.sort((a, b) => {
        let av = a[currentSort.key];
        let bv = b[currentSort.key];
        if (av === undefined) av = 0;
        if (bv === undefined) bv = 0;
        if (typeof av === 'number' && typeof bv === 'number') return (av - bv) * currentSort.dir;
        return String(av).localeCompare(String(bv)) * currentSort.dir;
    });

    const tbody = document.getElementById('tbody');
    tbody.innerHTML = filtered.map(w => {
        const bc = getBadgeClass(w.classification);
        const solClass = (w.solBalance || 0) > 0 ? '' : ' zero';
        const swapClass = (w.swapCount || 0) > 0 ? '' : ' zero';
        const tagsHtml = w.tags.map(t => '<span class="tag ' + t.toLowerCase() + '">' + t + '</span>').join('');
        const tokenList = (w.tokenSymbols || []).join(', ');

        return '<tr>' +
            '<td><input type="checkbox" class="checkbox" data-addr="' + w.address + '" onchange="updateSelectedCount()"></td>' +
            '<td class="token-count">' + w.tokenCount + '</td>' +
            '<td class="addr"><a href="profile.html?wallet=' + w.address + '" target="_blank" title="' + w.address + '">' + shortAddr(w.address) + '</a> <span class="copy-btn" onclick="copyAddr(\'' + w.address + '\')">[c]</span></td>' +
            '<td class="sol-bal' + solClass + '">' + (w.solBalance || 0).toFixed(2) + '</td>' +
            '<td class="swap-count' + swapClass + '">' + (w.swapCount || 0) + '</td>' +
            '<td>' + (w.totalSigs || 0) + '</td>' +
            '<td><span class="badge ' + bc + '">' + getBadgeLabel(w.classification) + '</span></td>' +
            '<td>' + tagsHtml + '</td>' +
            '<td class="token-list" title="' + tokenList + '">' + tokenList + '</td>' +
            '<td class="links">' +
                '<a href="profile.html?wallet=' + w.address + '" target="_blank" class="profile">Profile</a> ' +
                '<a href="https://solscan.io/account/' + w.address + '" target="_blank" class="solscan">Solscan</a> ' +
                '<a href="https://gmgn.ai/sol/address/' + w.address + '" target="_blank" class="gmgn">GMGN</a>' +
            '</td></tr>';
    }).join('');

    updateSelectedCount();
}

function setFilter(f, btn) {
    currentFilter = f;
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    renderTable();
}

// Sort
document.querySelectorAll('th[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
        const key = th.dataset.sort;
        if (currentSort.key === key) currentSort.dir *= -1;
        else { currentSort.key = key; currentSort.dir = -1; }
        document.querySelectorAll('th').forEach(t => t.classList.remove('sorted'));
        th.classList.add('sorted');
        renderTable();
    });
});

function toggleAll(el) {
    document.querySelectorAll('#tbody .checkbox').forEach(cb => { cb.checked = el.checked; });
    updateSelectedCount();
}

function updateSelectedCount() {
    const count = document.querySelectorAll('#tbody .checkbox:checked').length;
    document.getElementById('selectedCount').textContent = count + ' selected';
}

function copySelected() {
    const addrs = [];
    document.querySelectorAll('#tbody .checkbox:checked').forEach(cb => addrs.push(cb.dataset.addr));
    if (!addrs.length) return showToast('Nothing selected');
    navigator.clipboard.writeText(addrs.join('\n')).then(() => showToast(addrs.length + ' addresses copied'));
}

function copyAll() {
    const filtered = getFilteredResults();
    if (!filtered.length) return showToast('No results');
    navigator.clipboard.writeText(filtered.map(r => r.address).join('\n')).then(() => showToast(filtered.length + ' addresses copied'));
}

function exportJSON() {
    const selected = [];
    document.querySelectorAll('#tbody .checkbox:checked').forEach(cb => {
        const addr = cb.dataset.addr;
        const r = results.find(w => w.address === addr);
        if (r) selected.push(r);
    });
    const data = selected.length > 0 ? selected : getFilteredResults();
    if (!data.length) return showToast('No data to export');
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'power_traders.json'; a.click();
    URL.revokeObjectURL(url);
    showToast(data.length + ' wallets exported');
}

function copyAddr(addr) {
    navigator.clipboard.writeText(addr).then(() => showToast('Copied: ' + addr));
}

function showToast(msg) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.style.display = 'block';
    setTimeout(() => t.style.display = 'none', 2000);
}
</script>
<script src="shared.js"></script></body>
</html>
