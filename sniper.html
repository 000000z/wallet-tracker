<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claim Sniper - Chillz</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0f; color: #e0e0e0; font-family: 'SF Mono', 'Fira Code', monospace; font-size: 13px; }

/* Status Dashboard */
.status-panel {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 10px;
    padding: 16px 24px;
    border-bottom: 1px solid #1e1e2e;
}
.status-card {
    background: #12121a;
    border: 1px solid #1e1e2e;
    border-radius: 8px;
    padding: 12px 14px;
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.status-card .label {
    font-size: 10px;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 600;
}
.status-card .value {
    font-size: 16px;
    font-weight: 700;
    color: #e0e0e0;
}
.status-card .value.running { color: #22c55e; }
.status-card .value.stopped { color: #ef4444; }
.status-card .value.connecting { color: #f59e0b; }
.status-card .value.mono { font-size: 12px; font-weight: 400; cursor: help; }

/* Section cards */
.section {
    margin: 16px 24px;
    background: #12121a;
    border: 1px solid #1e1e2e;
    border-radius: 10px;
    padding: 16px 20px;
}
.section-title {
    font-size: 12px;
    color: #7dd3fc;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 700;
    margin-bottom: 14px;
    padding-bottom: 8px;
    border-bottom: 1px solid #1e1e2e;
}

/* Form rows */
.form-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px 20px;
}
.form-row {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.form-row.full { grid-column: 1 / -1; }
.form-row label {
    font-size: 11px;
    color: #888;
    font-weight: 600;
}
.form-row input, .form-row textarea {
    background: #0d0d14;
    border: 1px solid #2a2a3e;
    color: #e0e0e0;
    padding: 8px 12px;
    border-radius: 6px;
    font-family: inherit;
    font-size: 13px;
}
.form-row input:focus, .form-row textarea:focus { outline: none; border-color: #7dd3fc; }
.form-row textarea { resize: vertical; min-height: 60px; }
.form-row .hint {
    font-size: 10px;
    color: #444;
}

/* Password toggle */
.pw-wrap {
    position: relative;
}
.pw-wrap input { width: 100%; padding-right: 56px; }
.pw-toggle {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    background: #1e1e2e;
    border: none;
    color: #888;
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
}
.pw-toggle:hover { color: #ccc; }

/* Toggle switch */
.toggle-row {
    display: flex;
    align-items: center;
    gap: 10px;
}
.toggle-switch {
    width: 40px;
    height: 22px;
    background: #2a2a3e;
    border-radius: 11px;
    position: relative;
    cursor: pointer;
    transition: background 0.2s;
}
.toggle-switch.on { background: #22c55e44; }
.toggle-switch .toggle-knob {
    width: 16px;
    height: 16px;
    background: #555;
    border-radius: 50%;
    position: absolute;
    top: 3px;
    left: 3px;
    transition: all 0.2s;
}
.toggle-switch.on .toggle-knob {
    left: 21px;
    background: #22c55e;
}
.toggle-label {
    font-size: 12px;
    color: #888;
}

/* Controls */
.controls {
    display: flex;
    gap: 10px;
    padding: 0 24px 16px;
}
.btn {
    padding: 10px 20px;
    border-radius: 8px;
    border: 1px solid transparent;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    transition: all 0.15s;
}
.btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}
.btn-start {
    background: #22c55e22;
    border-color: #22c55e44;
    color: #22c55e;
}
.btn-start:hover:not(:disabled) { background: #22c55e33; }
.btn-stop {
    background: #ef444422;
    border-color: #ef444444;
    color: #ef4444;
}
.btn-stop:hover:not(:disabled) { background: #ef444433; }
.btn-clear {
    background: #1e1e2e;
    border-color: #2a2a3e;
    color: #888;
}
.btn-clear:hover:not(:disabled) { background: #2a2a3e; color: #ccc; }
.btn-refresh {
    background: #f59e0b22;
    border-color: #f59e0b44;
    color: #f59e0b;
}
.btn-refresh:hover:not(:disabled) { background: #f59e0b33; }
.btn-save {
    background: #7dd3fc22;
    border-color: #7dd3fc44;
    color: #7dd3fc;
    margin-top: 8px;
}
.btn-save:hover { background: #7dd3fc33; }

/* Bought tokens table */
.bought-section { display: none; }
.bought-section.visible { display: block; }
.bought-table {
    width: 100%;
    border-collapse: collapse;
}
.bought-table th {
    text-align: left;
    font-size: 10px;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 8px 10px;
    border-bottom: 1px solid #1e1e2e;
    font-weight: 600;
}
.bought-table td {
    padding: 8px 10px;
    border-bottom: 1px solid #1e1e2e08;
    font-size: 12px;
    color: #ccc;
}
.bought-table tr:hover td { background: #ffffff04; }
.bought-table a {
    color: #7dd3fc;
    text-decoration: none;
}
.bought-table a:hover { text-decoration: underline; }
.badge-dry {
    display: inline-block;
    background: #f59e0b22;
    color: #f59e0b;
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 4px;
    font-weight: 600;
}

/* Event log */
.alert-log {
    max-height: 500px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 2px;
}
.log-entry {
    font-size: 11px;
    padding: 6px 12px;
    border-radius: 4px;
    border-left: 3px solid #333;
    background: #0d0d14;
    display: flex;
    gap: 8px;
    line-height: 1.5;
}
.log-entry .log-time {
    color: #444;
    white-space: nowrap;
    flex-shrink: 0;
}
.log-entry .log-msg {
    color: #999;
    word-break: break-all;
}
.log-entry.info { border-left-color: #3b82f6; }
.log-entry.info .log-msg { color: #7dd3fc; }
.log-entry.claim { border-left-color: #f59e0b; }
.log-entry.claim .log-msg { color: #fbbf24; }
.log-entry.buy { border-left-color: #22c55e; }
.log-entry.buy .log-msg { color: #4ade80; }
.log-entry.skip { border-left-color: #555; }
.log-entry.skip .log-msg { color: #777; }
.log-entry.error { border-left-color: #ef4444; }
.log-entry.error .log-msg { color: #f87171; }

/* Scrollbar */
.alert-log::-webkit-scrollbar { width: 6px; }
.alert-log::-webkit-scrollbar-track { background: transparent; }
.alert-log::-webkit-scrollbar-thumb { background: #2a2a3e; border-radius: 3px; }

/* Responsive */
@media (max-width: 900px) {
    .status-panel { grid-template-columns: repeat(3, 1fr); }
    .form-grid { grid-template-columns: 1fr; }
}
</style>
<link rel="stylesheet" href="shared.css">
</head>
<body>

<!-- Status Dashboard -->
<div class="status-panel">
    <div class="status-card">
        <div class="label">Sniper</div>
        <div class="value stopped" id="statusSniper">Stopped</div>
    </div>
    <div class="status-card">
        <div class="label">Wallet</div>
        <div class="value mono" id="statusWallet" title="">--</div>
    </div>
    <div class="status-card">
        <div class="label">ETH Balance</div>
        <div class="value" id="statusBalance">--</div>
    </div>
    <div class="status-card">
        <div class="label">Current Block</div>
        <div class="value" id="statusBlock">--</div>
    </div>
    <div class="status-card">
        <div class="label">Claims Detected</div>
        <div class="value" id="statusClaims">0</div>
    </div>
    <div class="status-card">
        <div class="label">Buys Executed</div>
        <div class="value" id="statusBuys">0</div>
    </div>
</div>

<!-- Configuration -->
<div class="section">
    <div class="section-title">Configuration</div>
    <div class="form-grid">
        <div class="form-row">
            <label>Private Key</label>
            <div class="pw-wrap">
                <input type="password" id="cfgPrivateKey" placeholder="0x...">
                <button class="pw-toggle" onclick="togglePw()">show</button>
            </div>
            <div class="hint">Stored in browser localStorage only</div>
        </div>
        <div class="form-row">
            <label>RPC URL</label>
            <input type="text" id="cfgRpcUrl" placeholder="https://mainnet.base.org">
        </div>
        <div class="form-row">
            <label>Buy Amount (ETH)</label>
            <input type="number" id="cfgBuyAmount" step="0.001" min="0" placeholder="0.005">
        </div>
        <div class="form-row">
            <label>Slippage %</label>
            <input type="number" id="cfgSlippage" min="1" max="50" placeholder="10">
        </div>
        <div class="form-row">
            <label>Min Claim (wei)</label>
            <input type="text" id="cfgMinClaim" placeholder="1000000000000000">
        </div>
        <div class="form-row">
            <label>Poll Interval (ms)</label>
            <input type="number" id="cfgPollInterval" min="1000" max="30000" step="500" placeholder="3000">
        </div>
        <div class="form-row">
            <label>Max Buys / Token</label>
            <input type="number" id="cfgMaxBuys" min="1" max="10" placeholder="1">
        </div>
        <div class="form-row">
            <label>Dry Run</label>
            <div class="toggle-row">
                <div class="toggle-switch on" id="cfgDryRun" onclick="toggleDryRun()">
                    <div class="toggle-knob"></div>
                </div>
                <span class="toggle-label" id="dryRunLabel">ON — no real transactions</span>
            </div>
        </div>
        <div class="form-row full">
            <label>Watched Tokens (one per line, empty = all)</label>
            <textarea id="cfgWatchedTokens" rows="3" placeholder="0x...&#10;0x..."></textarea>
        </div>
        <div class="form-row full">
            <label>Blacklisted Tokens (one per line)</label>
            <textarea id="cfgBlacklistedTokens" rows="3" placeholder="0x...&#10;0x..."></textarea>
        </div>
    </div>
    <button class="btn btn-save" onclick="saveConfig()">Save Config</button>
</div>

<!-- Controls -->
<div class="controls">
    <button class="btn btn-start" id="btnStart" onclick="startSniper()">Start Sniper</button>
    <button class="btn btn-stop" id="btnStop" onclick="stopSniper()" disabled>Stop Sniper</button>
    <button class="btn btn-clear" onclick="clearLog()">Clear Log</button>
    <button class="btn btn-refresh" onclick="refreshBalance()">Refresh Balance</button>
</div>

<!-- Bought Tokens -->
<div class="section bought-section" id="boughtSection">
    <div class="section-title">Bought Tokens</div>
    <table class="bought-table">
        <thead>
            <tr>
                <th>Token</th>
                <th>Buy #</th>
                <th>Amount In</th>
                <th>Amount Out</th>
                <th>TX</th>
                <th>Time</th>
            </tr>
        </thead>
        <tbody id="boughtBody"></tbody>
    </table>
</div>

<!-- Event Log -->
<div class="section">
    <div class="section-title">Event Log</div>
    <div class="alert-log" id="eventLog"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.4/ethers.umd.min.js"></script>
<script src="shared.js"></script>
<script>
// ─── Constants (from sniper.js) ─────────────────────────────────────────────
const ADDRESSES = {
    feeLocker:       '0xF3622742b1E446D92e45E22923Ef11C2fcD55D68',
    clankerFactory:  '0xE85A59c628F7d27878ACeB4bf3b35733630083a9',
    universalRouter: '0x6ff5693b99212da76ad316178a184ab56d299b43',
    poolManager:     '0x498581ff718922c3f8e6a244956af099b2652b2b',
    v4Quoter:        '0x0d5e0f971ed27fbff6c2837bf31316121532048d',
};

const KNOWN_HOOKS = [
    { addr: '0xd60D6B218116cFd801E28F78d011a203D2b068Cc', fee: '0x800000', label: 'Dynamic v4.1' },
    { addr: '0x34a45c6B61876d739400Bd71228CbcbD4F53E8cC', fee: '0x800000', label: 'Dynamic v4.0' },
    { addr: '0xb429d62f8f3bFFb98CdB9569533eA23bF0Ba28CC', fee: '10000',   label: 'Static v4.1' },
    { addr: '0xDd5EeaFff7BD481AD55Db083062b13a3cdf0A68CC', fee: '10000',   label: 'Static v4.0' },
];

const WETH_BASE = '0x4200000000000000000000000000000000000006';

const TICK_SPACING = 200;
const GAS_LIMIT = 500000n;
const V4_SWAP_CMD = 0x10;
const SWAP_EXACT_IN_SINGLE = 0x06;
const SETTLE_ALL = 0x0c;
const TAKE_ALL = 0x0f;

// ─── ABIs ───────────────────────────────────────────────────────────────────
const FEE_LOCKER_ABI = [
    'event ClaimTokens(address indexed feeOwner, address indexed token, uint256 amountClaimed)',
];

const CLANKER_FACTORY_ABI = [
    'event TokenCreated(address indexed tokenAddress, address indexed creator, address hooks, uint24 fee, int24 tickSpacing)',
];

const UNIVERSAL_ROUTER_ABI = [
    'function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable',
];

const V4_QUOTER_ABI = [
    `function quoteExactInputSingle((
        address currency0,
        address currency1,
        uint24 fee,
        int24 tickSpacing,
        address hooks,
        uint128 amountIn,
        uint160 sqrtPriceLimitX96,
        bytes hookData
    )) external returns (uint256 amountOut, uint256 gasEstimate)`,
];

// ─── State ──────────────────────────────────────────────────────────────────
let running = false;
let pollTimer = null;
let lastBlock = 0;
let claimsDetected = 0;
let buysExecuted = 0;
const boughtTokens = new Map();
const poolKeyCache = new Map();
let buyHistory = [];

let provider = null;
let wallet = null;
let feeLocker = null;
let factory = null;
let quoter = null;

// ─── DOM refs ───────────────────────────────────────────────────────────────
const $status = document.getElementById('statusSniper');
const $wallet = document.getElementById('statusWallet');
const $balance = document.getElementById('statusBalance');
const $block = document.getElementById('statusBlock');
const $claims = document.getElementById('statusClaims');
const $buys = document.getElementById('statusBuys');
const $log = document.getElementById('eventLog');
const $boughtSection = document.getElementById('boughtSection');
const $boughtBody = document.getElementById('boughtBody');
const $btnStart = document.getElementById('btnStart');
const $btnStop = document.getElementById('btnStop');

// ─── Config ─────────────────────────────────────────────────────────────────
const CONFIG_DEFAULTS = {
    privateKey: '',
    rpcUrl: 'https://mainnet.base.org',
    buyAmountEth: '0.005',
    slippagePct: 10,
    minClaimAmountWei: '1000000000000000',
    pollIntervalMs: 3000,
    maxBuysPerToken: 1,
    dryRun: true,
    watchedTokens: '',
    blacklistedTokens: '',
};

function getConfig() {
    const c = {};
    for (const [key, def] of Object.entries(CONFIG_DEFAULTS)) {
        const stored = localStorage.getItem('sniper_' + key);
        if (stored !== null) {
            if (typeof def === 'number') c[key] = Number(stored);
            else if (typeof def === 'boolean') c[key] = stored === 'true';
            else c[key] = stored;
        } else {
            c[key] = def;
        }
    }
    return c;
}

function loadConfigToForm() {
    const c = getConfig();
    document.getElementById('cfgPrivateKey').value = c.privateKey;
    document.getElementById('cfgRpcUrl').value = c.rpcUrl;
    document.getElementById('cfgBuyAmount').value = c.buyAmountEth;
    document.getElementById('cfgSlippage').value = c.slippagePct;
    document.getElementById('cfgMinClaim').value = c.minClaimAmountWei;
    document.getElementById('cfgPollInterval').value = c.pollIntervalMs;
    document.getElementById('cfgMaxBuys').value = c.maxBuysPerToken;
    // Dry run toggle
    const toggle = document.getElementById('cfgDryRun');
    const label = document.getElementById('dryRunLabel');
    if (c.dryRun) {
        toggle.classList.add('on');
        label.textContent = 'ON \u2014 no real transactions';
    } else {
        toggle.classList.remove('on');
        label.textContent = 'OFF \u2014 LIVE trading';
    }
    document.getElementById('cfgWatchedTokens').value = c.watchedTokens;
    document.getElementById('cfgBlacklistedTokens').value = c.blacklistedTokens;
}

function saveConfig() {
    localStorage.setItem('sniper_privateKey', document.getElementById('cfgPrivateKey').value.trim());
    localStorage.setItem('sniper_rpcUrl', document.getElementById('cfgRpcUrl').value.trim());
    localStorage.setItem('sniper_buyAmountEth', document.getElementById('cfgBuyAmount').value);
    localStorage.setItem('sniper_slippagePct', document.getElementById('cfgSlippage').value);
    localStorage.setItem('sniper_minClaimAmountWei', document.getElementById('cfgMinClaim').value.trim());
    localStorage.setItem('sniper_pollIntervalMs', document.getElementById('cfgPollInterval').value);
    localStorage.setItem('sniper_maxBuysPerToken', document.getElementById('cfgMaxBuys').value);
    const isDry = document.getElementById('cfgDryRun').classList.contains('on');
    localStorage.setItem('sniper_dryRun', isDry.toString());
    localStorage.setItem('sniper_watchedTokens', document.getElementById('cfgWatchedTokens').value.trim());
    localStorage.setItem('sniper_blacklistedTokens', document.getElementById('cfgBlacklistedTokens').value.trim());
    logEvent('info', 'Config saved');
}

function toggleDryRun() {
    const toggle = document.getElementById('cfgDryRun');
    const label = document.getElementById('dryRunLabel');
    toggle.classList.toggle('on');
    if (toggle.classList.contains('on')) {
        label.textContent = 'ON \u2014 no real transactions';
    } else {
        label.textContent = 'OFF \u2014 LIVE trading';
    }
}

function togglePw() {
    const inp = document.getElementById('cfgPrivateKey');
    const btn = inp.nextElementSibling;
    if (inp.type === 'password') {
        inp.type = 'text';
        btn.textContent = 'hide';
    } else {
        inp.type = 'password';
        btn.textContent = 'show';
    }
}

// ─── Buy History Persistence ────────────────────────────────────────────────
function loadBuyHistory() {
    try {
        buyHistory = JSON.parse(localStorage.getItem('sniper_buyHistory') || '[]');
    } catch { buyHistory = []; }
    renderBuyHistory();
}

function saveBuyHistory() {
    localStorage.setItem('sniper_buyHistory', JSON.stringify(buyHistory));
}

function renderBuyHistory() {
    if (buyHistory.length === 0) {
        $boughtSection.classList.remove('visible');
        return;
    }
    $boughtSection.classList.add('visible');
    $boughtBody.innerHTML = buyHistory.map(b => {
        const shortToken = b.token.slice(0, 6) + '...' + b.token.slice(-4);
        const txCell = b.dryRun
            ? '<span class="badge-dry">dry run</span>'
            : '<a href="https://basescan.org/tx/' + b.txHash + '" target="_blank">' + b.txHash.slice(0, 10) + '...</a>';
        return '<tr>' +
            '<td><a href="https://basescan.org/token/' + b.token + '" target="_blank">' + shortToken + '</a></td>' +
            '<td>' + b.buyCount + '</td>' +
            '<td>' + b.amountIn + ' ETH</td>' +
            '<td>' + b.amountOut + '</td>' +
            '<td>' + txCell + '</td>' +
            '<td>' + new Date(b.time).toLocaleTimeString() + '</td>' +
        '</tr>';
    }).join('');
}

// ─── Event Log ──────────────────────────────────────────────────────────────
const MAX_LOG_ENTRIES = 500;

function logEvent(type, msg) {
    const now = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + type;
    entry.innerHTML = '<span class="log-time">' + now + '</span><span class="log-msg">' + escapeHtml(msg) + '</span>';
    // Newest first
    $log.insertBefore(entry, $log.firstChild);
    // Cap entries
    while ($log.children.length > MAX_LOG_ENTRIES) {
        $log.removeChild($log.lastChild);
    }
}

function escapeHtml(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function clearLog() {
    $log.innerHTML = '';
    logEvent('info', 'Log cleared');
}

// ─── Pool Resolution (ported from sniper.js) ────────────────────────────────
async function resolvePoolKey(tokenAddress, amountIn) {
    const tokenLower = tokenAddress.toLowerCase();
    if (poolKeyCache.has(tokenLower)) return poolKeyCache.get(tokenLower);

    // Strategy 1: Factory event lookup
    try {
        const filter = factory.filters.TokenCreated(tokenAddress);
        const events = await factory.queryFilter(filter, 0, 'latest');
        if (events.length > 0) {
            const ev = events[0];
            const poolKey = {
                hooks: ev.args.hooks,
                fee: ev.args.fee.toString(),
                tickSpacing: Number(ev.args.tickSpacing),
            };
            logEvent('info', '  Pool resolved via factory event: hook=' + poolKey.hooks + ', fee=' + poolKey.fee);
            poolKeyCache.set(tokenLower, poolKey);
            return poolKey;
        }
    } catch (err) {
        logEvent('error', '  Factory event lookup failed: ' + err.message);
    }

    // Strategy 2: Known hook probing
    logEvent('info', '  Trying known hooks via quoter...');
    for (const hook of KNOWN_HOOKS) {
        try {
            const params = {
                currency0: ethers.ZeroAddress,
                currency1: tokenAddress,
                fee: hook.fee,
                tickSpacing: TICK_SPACING,
                hooks: hook.addr,
                amountIn: amountIn,
                sqrtPriceLimitX96: 0n,
                hookData: '0x',
            };
            const result = await quoter.quoteExactInputSingle.staticCall(params);
            if (result.amountOut > 0n) {
                const poolKey = {
                    hooks: hook.addr,
                    fee: hook.fee,
                    tickSpacing: TICK_SPACING,
                };
                logEvent('info', '  Pool resolved via quoter: ' + hook.label);
                poolKeyCache.set(tokenLower, poolKey);
                return poolKey;
            }
        } catch {
            // try next hook
        }
    }

    return null;
}

// ─── Swap Encoding (ported from sniper.js) ──────────────────────────────────
function encodeV4Swap(tokenAddress, poolKey, amountIn, amountOutMin) {
    const actions = ethers.solidityPacked(
        ['uint8', 'uint8', 'uint8'],
        [SWAP_EXACT_IN_SINGLE, SETTLE_ALL, TAKE_ALL]
    );

    const currency0 = ethers.ZeroAddress;
    const currency1 = tokenAddress;

    const swapParams = ethers.AbiCoder.defaultAbiCoder().encode(
        ['tuple(tuple(address,address,uint24,int24,address) poolKey, bool zeroForOne, uint128 amountIn, uint128 amountOutMinimum, uint160 sqrtPriceLimitX96, bytes hookData)'],
        [{
            poolKey: {
                0: currency0,
                1: currency1,
                2: poolKey.fee,
                3: poolKey.tickSpacing,
                4: poolKey.hooks,
            },
            zeroForOne: true,
            amountIn: amountIn,
            amountOutMinimum: amountOutMin,
            sqrtPriceLimitX96: 0n,
            hookData: '0x',
        }]
    );

    const settleParams = ethers.AbiCoder.defaultAbiCoder().encode(
        ['address', 'uint256'],
        [currency0, amountIn]
    );

    const takeParams = ethers.AbiCoder.defaultAbiCoder().encode(
        ['address', 'uint256'],
        [currency1, amountOutMin]
    );

    const v4Input = ethers.AbiCoder.defaultAbiCoder().encode(
        ['bytes', 'bytes[]'],
        [actions, [swapParams, settleParams, takeParams]]
    );

    const commands = ethers.solidityPacked(['uint8'], [V4_SWAP_CMD]);
    return { commands, inputs: [v4Input] };
}

// ─── Execute Buy (ported from sniper.js) ────────────────────────────────────
async function executeBuy(tokenAddress, poolKey) {
    const config = getConfig();
    const amountIn = ethers.parseEther(config.buyAmountEth);

    // Get quote
    let amountOut;
    try {
        const quoteParams = {
            currency0: ethers.ZeroAddress,
            currency1: tokenAddress,
            fee: poolKey.fee,
            tickSpacing: poolKey.tickSpacing,
            hooks: poolKey.hooks,
            amountIn: amountIn,
            sqrtPriceLimitX96: 0n,
            hookData: '0x',
        };
        const result = await quoter.quoteExactInputSingle.staticCall(quoteParams);
        amountOut = result[0];
        logEvent('info', '  Quote: ' + ethers.formatEther(amountIn) + ' ETH -> ' + amountOut.toString() + ' tokens');
    } catch (err) {
        logEvent('error', '  Quote failed: ' + err.message);
        return null;
    }

    // Apply slippage
    const slippageBps = BigInt(config.slippagePct * 100);
    const amountOutMin = amountOut * (10000n - slippageBps) / 10000n;
    logEvent('info', '  Min output (' + config.slippagePct + '% slippage): ' + amountOutMin.toString() + ' tokens');

    const buyCount = (boughtTokens.get(tokenAddress.toLowerCase()) || 0) + 1;

    if (config.dryRun) {
        logEvent('buy', 'DRY RUN: Would buy ' + tokenAddress.slice(0, 10) + '... with ' + config.buyAmountEth + ' ETH, expected ~' + amountOut.toString() + ' tokens');
        const entry = {
            token: tokenAddress,
            buyCount: buyCount,
            amountIn: config.buyAmountEth,
            amountOut: amountOut.toString(),
            txHash: '',
            dryRun: true,
            time: Date.now(),
        };
        buyHistory.unshift(entry);
        saveBuyHistory();
        renderBuyHistory();
        return { dryRun: true, amountOut: amountOut.toString() };
    }

    // Encode and send
    const { commands, inputs } = encodeV4Swap(tokenAddress, poolKey, amountIn, amountOutMin);
    const deadline = Math.floor(Date.now() / 1000) + 120;
    const router = new ethers.Contract(ADDRESSES.universalRouter, UNIVERSAL_ROUTER_ABI, wallet);

    try {
        const tx = await router.execute(commands, inputs, deadline, {
            value: amountIn,
            gasLimit: GAS_LIMIT,
        });
        logEvent('buy', 'TX sent: ' + tx.hash);
        logEvent('info', '  Waiting for confirmation...');

        const receipt = await tx.wait();
        logEvent('buy', 'TX confirmed in block ' + receipt.blockNumber + ', gas used: ' + receipt.gasUsed.toString());
        logEvent('buy', 'BaseScan: https://basescan.org/tx/' + tx.hash);

        const entry = {
            token: tokenAddress,
            buyCount: buyCount,
            amountIn: config.buyAmountEth,
            amountOut: amountOut.toString(),
            txHash: tx.hash,
            dryRun: false,
            time: Date.now(),
        };
        buyHistory.unshift(entry);
        saveBuyHistory();
        renderBuyHistory();

        return { txHash: tx.hash, blockNumber: receipt.blockNumber, amountOut: amountOut.toString() };
    } catch (err) {
        logEvent('error', 'TX failed: ' + err.message);
        return null;
    }
}

// ─── Resolve creator's actual token from factory ────────────────────────────
const creatorTokenCache = new Map();

async function resolveCreatorToken(feeOwner) {
    const ownerLower = feeOwner.toLowerCase();
    if (creatorTokenCache.has(ownerLower)) return creatorTokenCache.get(ownerLower);

    try {
        const filter = factory.filters.TokenCreated(null, feeOwner);
        const events = await factory.queryFilter(filter, 0, 'latest');
        if (events.length > 0) {
            // Return the most recent token this creator deployed
            const tokenAddr = events[events.length - 1].args.tokenAddress;
            creatorTokenCache.set(ownerLower, tokenAddr);
            return tokenAddr;
        }
    } catch (err) {
        logEvent('error', '  Creator token lookup failed: ' + err.message);
    }
    return null;
}

// ─── Process Claim (ported from sniper.js) ──────────────────────────────────
async function processClaim(event) {
    const { feeOwner, token, amountClaimed } = event.args;
    const config = getConfig();

    claimsDetected++;
    $claims.textContent = claimsDetected;

    // Determine the actual token to buy
    let buyToken = token;
    const isWethClaim = token.toLowerCase() === WETH_BASE.toLowerCase();

    if (isWethClaim) {
        logEvent('claim', 'WETH FEE CLAIM from ' + feeOwner.slice(0, 10) + '... (' + ethers.formatEther(amountClaimed) + ' ETH)');
        logEvent('info', '  Resolving creator\'s actual token...');
        const actualToken = await resolveCreatorToken(feeOwner);
        if (!actualToken) {
            logEvent('skip', '  SKIP: Could not find token for creator ' + feeOwner.slice(0, 10) + '...');
            return;
        }
        buyToken = actualToken;
        logEvent('claim', '  Resolved token: ' + buyToken);
    } else {
        logEvent('claim', 'CLAIM DETECTED:');
        logEvent('claim', '  Fee Owner: ' + feeOwner);
        logEvent('claim', '  Token: ' + token);
    }

    logEvent('claim', '  Claim Amount: ' + amountClaimed.toString() + ' wei (' + ethers.formatEther(amountClaimed) + ' ETH)');

    // Filter: min claim
    if (amountClaimed < BigInt(config.minClaimAmountWei)) {
        logEvent('skip', '  SKIP: Claim below minimum (' + config.minClaimAmountWei + ' wei)');
        return;
    }

    // Filter: watched tokens
    const watchedList = config.watchedTokens.split('\n').map(s => s.trim()).filter(Boolean);
    if (watchedList.length > 0) {
        const isWatched = watchedList.some(w => w.toLowerCase() === buyToken.toLowerCase());
        if (!isWatched) {
            logEvent('skip', '  SKIP: Token ' + buyToken.slice(0, 10) + '... not in watched list');
            return;
        }
    }

    // Filter: blacklist
    const blacklist = config.blacklistedTokens.split('\n').map(s => s.trim()).filter(Boolean);
    if (blacklist.length > 0) {
        const isBlacklisted = blacklist.some(b => b.toLowerCase() === buyToken.toLowerCase());
        if (isBlacklisted) {
            logEvent('skip', '  SKIP: Token ' + buyToken.slice(0, 10) + '... is blacklisted');
            return;
        }
    }

    // Filter: max buys
    const buyCount = boughtTokens.get(buyToken.toLowerCase()) || 0;
    if (buyCount >= config.maxBuysPerToken) {
        logEvent('skip', '  SKIP: Already bought ' + buyToken.slice(0, 10) + '... ' + buyCount + 'x (max: ' + config.maxBuysPerToken + ')');
        return;
    }

    // Resolve pool
    const amountIn = ethers.parseEther(config.buyAmountEth);
    const poolKey = await resolvePoolKey(buyToken, amountIn);
    if (!poolKey) {
        logEvent('error', '  SKIP: Could not resolve pool for ' + buyToken);
        return;
    }

    // Execute buy
    logEvent('info', '  BUYING ' + buyToken.slice(0, 10) + '... with ' + config.buyAmountEth + ' ETH...');
    const result = await executeBuy(buyToken, poolKey);

    if (result) {
        boughtTokens.set(buyToken.toLowerCase(), buyCount + 1);
        buysExecuted++;
        $buys.textContent = buysExecuted;
        logEvent('buy', 'BUY COMPLETE for ' + buyToken.slice(0, 10) + '...');
    }
}

// ─── Poll Loop ──────────────────────────────────────────────────────────────
async function pollOnce() {
    if (!running) return;

    try {
        const currentBlock = await provider.getBlockNumber();
        $block.textContent = currentBlock.toLocaleString();

        if (currentBlock > lastBlock) {
            const filter = feeLocker.filters.ClaimTokens();
            const events = await feeLocker.queryFilter(filter, lastBlock + 1, currentBlock);

            if (events.length > 0) {
                logEvent('info', 'Found ' + events.length + ' claim(s) in blocks ' + (lastBlock + 1) + '-' + currentBlock);
            }

            for (const event of events) {
                try {
                    await processClaim(event);
                } catch (err) {
                    logEvent('error', 'Error processing claim: ' + err.message);
                }
            }

            lastBlock = currentBlock;
        }
    } catch (err) {
        logEvent('error', 'Poll error: ' + err.message);
    }

    if (running) {
        const config = getConfig();
        pollTimer = setTimeout(pollOnce, config.pollIntervalMs);
    }
}

// ─── Start / Stop ───────────────────────────────────────────────────────────
async function startSniper() {
    const config = getConfig();

    if (!config.privateKey || config.privateKey === 'YOUR_BASE_WALLET_PRIVATE_KEY') {
        logEvent('error', 'Set your private key in config before starting');
        return;
    }

    saveConfig();

    $status.textContent = 'Connecting';
    $status.className = 'value connecting';
    $btnStart.disabled = true;
    logEvent('info', 'Connecting to ' + config.rpcUrl + '...');

    try {
        provider = new ethers.JsonRpcProvider(config.rpcUrl);
        wallet = new ethers.Wallet(config.privateKey, provider);

        // Display wallet
        const addr = wallet.address;
        $wallet.textContent = addr.slice(0, 6) + '...' + addr.slice(-4);
        $wallet.title = addr;

        // Get balance
        const balance = await provider.getBalance(addr);
        $balance.textContent = parseFloat(ethers.formatEther(balance)).toFixed(4) + ' ETH';
        if (balance === 0n) {
            logEvent('error', 'WARNING: Wallet has 0 ETH — swaps will fail');
        }

        // Init contracts
        feeLocker = new ethers.Contract(ADDRESSES.feeLocker, FEE_LOCKER_ABI, provider);
        factory = new ethers.Contract(ADDRESSES.clankerFactory, CLANKER_FACTORY_ABI, provider);
        quoter = new ethers.Contract(ADDRESSES.v4Quoter, V4_QUOTER_ABI, provider);

        // Start from current block
        lastBlock = await provider.getBlockNumber();
        $block.textContent = lastBlock.toLocaleString();

        running = true;
        $status.textContent = 'Running';
        $status.className = 'value running';
        $btnStart.disabled = true;
        $btnStop.disabled = false;

        logEvent('info', '═══ Clanker Claim Sniper Started ═══');
        logEvent('info', 'Wallet: ' + addr);
        logEvent('info', 'Balance: ' + ethers.formatEther(balance) + ' ETH');
        logEvent('info', 'Buy Amount: ' + config.buyAmountEth + ' ETH | Slippage: ' + config.slippagePct + '%');
        logEvent('info', 'Dry Run: ' + (config.dryRun ? 'ON' : 'OFF') + ' | Poll: ' + config.pollIntervalMs + 'ms');
        logEvent('info', 'Starting from block ' + lastBlock);
        logEvent('info', 'Listening for ClaimTokens events...');

        // Reset session counters
        claimsDetected = 0;
        buysExecuted = 0;
        $claims.textContent = '0';
        $buys.textContent = '0';

        // Begin polling
        pollTimer = setTimeout(pollOnce, config.pollIntervalMs);

    } catch (err) {
        logEvent('error', 'Failed to connect: ' + err.message);
        $status.textContent = 'Stopped';
        $status.className = 'value stopped';
        $btnStart.disabled = false;
        running = false;
    }
}

function stopSniper() {
    running = false;
    if (pollTimer) {
        clearTimeout(pollTimer);
        pollTimer = null;
    }
    $status.textContent = 'Stopped';
    $status.className = 'value stopped';
    $btnStart.disabled = false;
    $btnStop.disabled = true;
    logEvent('info', 'Sniper stopped');
}

async function refreshBalance() {
    if (!provider || !wallet) {
        logEvent('error', 'Not connected — start sniper first');
        return;
    }
    try {
        const balance = await provider.getBalance(wallet.address);
        $balance.textContent = parseFloat(ethers.formatEther(balance)).toFixed(4) + ' ETH';
        logEvent('info', 'Balance refreshed: ' + ethers.formatEther(balance) + ' ETH');
    } catch (err) {
        logEvent('error', 'Balance refresh failed: ' + err.message);
    }
}

// ─── Init ───────────────────────────────────────────────────────────────────
loadConfigToForm();
loadBuyHistory();
</script>
</body>
</html>
